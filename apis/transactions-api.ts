/* tslint:disable */
/* eslint-disable */
/**
 * Satstream API
 * Satstream API
 *
 * OpenAPI spec version: 1.0
 * Contact: team@satstream.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse20033 } from '../models';
import { InlineResponse20034 } from '../models';
import { InlineResponse20035 } from '../models';
import { InlineResponse20036 } from '../models';
import { InlineResponse20037 } from '../models';
import { InlineResponse20038 } from '../models';
import { InlineResponse20039 } from '../models';
import { InlineResponse20040 } from '../models';
import { InlineResponse2005 } from '../models';
import { RequestsCombineRawTransactionRequest } from '../models';
import { RequestsConvertToPSBTRequest } from '../models';
import { RequestsCreateRawTxRequest } from '../models';
import { RequestsGetTxOutProofRequest } from '../models';
import { RequestsGetTxOutRequest } from '../models';
import { RequestsGetTxOutSetInfoRequest } from '../models';
import { RequestsGetTxSpendingPrevoutRequest } from '../models';
import { RequestsSendRawTransactionRequest } from '../models';
import { RequestsVerifyTxOutProofRequest } from '../models';
import { UtilsResponseEnvelope } from '../models';
/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Combines multiple partially signed transactions into one transaction
         * @summary Combine Raw Transactions
         * @param {RequestsCombineRawTransactionRequest} body Array of hex-encoded raw transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        combineRawTransaction: async (body: RequestsCombineRawTransactionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling combineRawTransaction.');
            }
            const localVarPath = `/tx/combine`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction. createpsbt and walletcreatefundedpsbt should be used for new applications.
         * @summary Convert Raw Transaction to PSBT
         * @param {RequestsConvertToPSBTRequest} body Raw transaction conversion parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertToPsbt: async (body: RequestsConvertToPSBTRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling convertToPsbt.');
            }
            const localVarPath = `/tx/convert-to-psbt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a raw transaction spending the given inputs and creating new outputs. Note that the transaction's inputs are not signed, and it is not stored in the wallet or transmitted to the network.
         * @summary Create Raw Transaction
         * @param {RequestsCreateRawTxRequest} body Transaction parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawTransaction: async (body: RequestsCreateRawTxRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRawTransaction.');
            }
            const localVarPath = `/tx/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Decodes a transaction and returns its inscriptions and runestone data
         * @summary Decode a transaction
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decodeTx: async (txid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txid' is not null or undefined
            if (txid === null || txid === undefined) {
                throw new RequiredError('txid','Required parameter txid was null or undefined when calling decodeTx.');
            }
            const localVarPath = `/tx/{txid}/decode`
                .replace(`{${"txid"}}`, encodeURIComponent(String(txid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get raw transaction as a decoded object
         * @summary Get raw transaction (verbosity 1)
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawTransactionDecoded: async (txid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txid' is not null or undefined
            if (txid === null || txid === undefined) {
                throw new RequiredError('txid','Required parameter txid was null or undefined when calling getRawTransactionDecoded.');
            }
            const localVarPath = `/tx/{txid}/decoded`
                .replace(`{${"txid"}}`, encodeURIComponent(String(txid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get raw transaction as a raw hex string
         * @summary Get raw transaction (verbosity 0)
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawTransactionHex: async (txid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txid' is not null or undefined
            if (txid === null || txid === undefined) {
                throw new RequiredError('txid','Required parameter txid was null or undefined when calling getRawTransactionHex.');
            }
            const localVarPath = `/tx/{txid}/hex`
                .replace(`{${"txid"}}`, encodeURIComponent(String(txid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get raw transaction with prevout information
         * @summary Get raw transaction (verbosity 2)
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawTransactionPrevout: async (txid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txid' is not null or undefined
            if (txid === null || txid === undefined) {
                throw new RequiredError('txid','Required parameter txid was null or undefined when calling getRawTransactionPrevout.');
            }
            const localVarPath = `/tx/{txid}/prevout`
                .replace(`{${"txid"}}`, encodeURIComponent(String(txid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information about a specific transaction
         * @summary Get transaction info
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction: async (txid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txid' is not null or undefined
            if (txid === null || txid === undefined) {
                throw new RequiredError('txid','Required parameter txid was null or undefined when calling getTransaction.');
            }
            const localVarPath = `/tx/{txid}`
                .replace(`{${"txid"}}`, encodeURIComponent(String(txid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details about an unspent transaction output
         * @summary Get transaction output
         * @param {RequestsGetTxOutRequest} body Transaction output request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxOut: async (body: RequestsGetTxOutRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getTxOut.');
            }
            const localVarPath = `/tx/out`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a hex-encoded proof that one or more specified transactions were included in a block
         * @summary Get transaction output proof
         * @param {RequestsGetTxOutProofRequest} body Transaction proof request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxOutProof: async (body: RequestsGetTxOutProofRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getTxOutProof.');
            }
            const localVarPath = `/tx/outproof`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns statistics about the unspent transaction output set
         * @summary Get transaction output set information
         * @param {RequestsGetTxOutSetInfoRequest} body UTXO set info request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxOutSetInfo: async (body: RequestsGetTxOutSetInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getTxOutSetInfo.');
            }
            const localVarPath = `/tx/out/set/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Scans the mempool to find transactions spending any of the given outputs
         * @summary Get transaction spending prevout
         * @param {RequestsGetTxSpendingPrevoutRequest} body Transaction spending prevout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxSpendingPrevout: async (body: RequestsGetTxSpendingPrevoutRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getTxSpendingPrevout.');
            }
            const localVarPath = `/tx/spending-prevout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a raw transaction to local node and network
         * @summary Send raw transaction
         * @param {RequestsSendRawTransactionRequest} body Raw transaction to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRawTransaction: async (body: RequestsSendRawTransactionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendRawTransaction.');
            }
            const localVarPath = `/tx/send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies that a proof points to a transaction in a block
         * @summary Verify transaction output proof
         * @param {RequestsVerifyTxOutProofRequest} body Proof to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyTxOutProof: async (body: RequestsVerifyTxOutProofRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling verifyTxOutProof.');
            }
            const localVarPath = `/tx/outproof/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Combines multiple partially signed transactions into one transaction
         * @summary Combine Raw Transactions
         * @param {RequestsCombineRawTransactionRequest} body Array of hex-encoded raw transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async combineRawTransaction(body: RequestsCombineRawTransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2005>>> {
            const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(configuration).combineRawTransaction(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Converts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction. createpsbt and walletcreatefundedpsbt should be used for new applications.
         * @summary Convert Raw Transaction to PSBT
         * @param {RequestsConvertToPSBTRequest} body Raw transaction conversion parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async convertToPsbt(body: RequestsConvertToPSBTRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2005>>> {
            const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(configuration).convertToPsbt(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a raw transaction spending the given inputs and creating new outputs. Note that the transaction's inputs are not signed, and it is not stored in the wallet or transmitted to the network.
         * @summary Create Raw Transaction
         * @param {RequestsCreateRawTxRequest} body Transaction parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRawTransaction(body: RequestsCreateRawTxRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2005>>> {
            const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(configuration).createRawTransaction(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Decodes a transaction and returns its inscriptions and runestone data
         * @summary Decode a transaction
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async decodeTx(txid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20038>>> {
            const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(configuration).decodeTx(txid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get raw transaction as a decoded object
         * @summary Get raw transaction (verbosity 1)
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawTransactionDecoded(txid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20039>>> {
            const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(configuration).getRawTransactionDecoded(txid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get raw transaction as a raw hex string
         * @summary Get raw transaction (verbosity 0)
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawTransactionHex(txid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2005>>> {
            const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(configuration).getRawTransactionHex(txid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get raw transaction with prevout information
         * @summary Get raw transaction (verbosity 2)
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawTransactionPrevout(txid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20040>>> {
            const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(configuration).getRawTransactionPrevout(txid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve information about a specific transaction
         * @summary Get transaction info
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransaction(txid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20037>>> {
            const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(configuration).getTransaction(txid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns details about an unspent transaction output
         * @summary Get transaction output
         * @param {RequestsGetTxOutRequest} body Transaction output request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxOut(body: RequestsGetTxOutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20033>>> {
            const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(configuration).getTxOut(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a hex-encoded proof that one or more specified transactions were included in a block
         * @summary Get transaction output proof
         * @param {RequestsGetTxOutProofRequest} body Transaction proof request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxOutProof(body: RequestsGetTxOutProofRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2005>>> {
            const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(configuration).getTxOutProof(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns statistics about the unspent transaction output set
         * @summary Get transaction output set information
         * @param {RequestsGetTxOutSetInfoRequest} body UTXO set info request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxOutSetInfo(body: RequestsGetTxOutSetInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20034>>> {
            const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(configuration).getTxOutSetInfo(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Scans the mempool to find transactions spending any of the given outputs
         * @summary Get transaction spending prevout
         * @param {RequestsGetTxSpendingPrevoutRequest} body Transaction spending prevout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxSpendingPrevout(body: RequestsGetTxSpendingPrevoutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20036>>> {
            const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(configuration).getTxSpendingPrevout(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Submits a raw transaction to local node and network
         * @summary Send raw transaction
         * @param {RequestsSendRawTransactionRequest} body Raw transaction to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendRawTransaction(body: RequestsSendRawTransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2005>>> {
            const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(configuration).sendRawTransaction(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Verifies that a proof points to a transaction in a block
         * @summary Verify transaction output proof
         * @param {RequestsVerifyTxOutProofRequest} body Proof to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyTxOutProof(body: RequestsVerifyTxOutProofRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20035>>> {
            const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(configuration).verifyTxOutProof(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Combines multiple partially signed transactions into one transaction
         * @summary Combine Raw Transactions
         * @param {RequestsCombineRawTransactionRequest} body Array of hex-encoded raw transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async combineRawTransaction(body: RequestsCombineRawTransactionRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2005>> {
            return TransactionsApiFp(configuration).combineRawTransaction(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Converts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction. createpsbt and walletcreatefundedpsbt should be used for new applications.
         * @summary Convert Raw Transaction to PSBT
         * @param {RequestsConvertToPSBTRequest} body Raw transaction conversion parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async convertToPsbt(body: RequestsConvertToPSBTRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2005>> {
            return TransactionsApiFp(configuration).convertToPsbt(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a raw transaction spending the given inputs and creating new outputs. Note that the transaction's inputs are not signed, and it is not stored in the wallet or transmitted to the network.
         * @summary Create Raw Transaction
         * @param {RequestsCreateRawTxRequest} body Transaction parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRawTransaction(body: RequestsCreateRawTxRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2005>> {
            return TransactionsApiFp(configuration).createRawTransaction(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Decodes a transaction and returns its inscriptions and runestone data
         * @summary Decode a transaction
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async decodeTx(txid: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20038>> {
            return TransactionsApiFp(configuration).decodeTx(txid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get raw transaction as a decoded object
         * @summary Get raw transaction (verbosity 1)
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawTransactionDecoded(txid: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20039>> {
            return TransactionsApiFp(configuration).getRawTransactionDecoded(txid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get raw transaction as a raw hex string
         * @summary Get raw transaction (verbosity 0)
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawTransactionHex(txid: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2005>> {
            return TransactionsApiFp(configuration).getRawTransactionHex(txid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get raw transaction with prevout information
         * @summary Get raw transaction (verbosity 2)
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawTransactionPrevout(txid: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20040>> {
            return TransactionsApiFp(configuration).getRawTransactionPrevout(txid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information about a specific transaction
         * @summary Get transaction info
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransaction(txid: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20037>> {
            return TransactionsApiFp(configuration).getTransaction(txid, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns details about an unspent transaction output
         * @summary Get transaction output
         * @param {RequestsGetTxOutRequest} body Transaction output request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxOut(body: RequestsGetTxOutRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20033>> {
            return TransactionsApiFp(configuration).getTxOut(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a hex-encoded proof that one or more specified transactions were included in a block
         * @summary Get transaction output proof
         * @param {RequestsGetTxOutProofRequest} body Transaction proof request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxOutProof(body: RequestsGetTxOutProofRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2005>> {
            return TransactionsApiFp(configuration).getTxOutProof(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns statistics about the unspent transaction output set
         * @summary Get transaction output set information
         * @param {RequestsGetTxOutSetInfoRequest} body UTXO set info request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxOutSetInfo(body: RequestsGetTxOutSetInfoRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20034>> {
            return TransactionsApiFp(configuration).getTxOutSetInfo(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Scans the mempool to find transactions spending any of the given outputs
         * @summary Get transaction spending prevout
         * @param {RequestsGetTxSpendingPrevoutRequest} body Transaction spending prevout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxSpendingPrevout(body: RequestsGetTxSpendingPrevoutRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20036>> {
            return TransactionsApiFp(configuration).getTxSpendingPrevout(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits a raw transaction to local node and network
         * @summary Send raw transaction
         * @param {RequestsSendRawTransactionRequest} body Raw transaction to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendRawTransaction(body: RequestsSendRawTransactionRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2005>> {
            return TransactionsApiFp(configuration).sendRawTransaction(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies that a proof points to a transaction in a block
         * @summary Verify transaction output proof
         * @param {RequestsVerifyTxOutProofRequest} body Proof to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyTxOutProof(body: RequestsVerifyTxOutProofRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20035>> {
            return TransactionsApiFp(configuration).verifyTxOutProof(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Combines multiple partially signed transactions into one transaction
     * @summary Combine Raw Transactions
     * @param {RequestsCombineRawTransactionRequest} body Array of hex-encoded raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public async combineRawTransaction(body: RequestsCombineRawTransactionRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2005>> {
        return TransactionsApiFp(this.configuration).combineRawTransaction(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Converts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction. createpsbt and walletcreatefundedpsbt should be used for new applications.
     * @summary Convert Raw Transaction to PSBT
     * @param {RequestsConvertToPSBTRequest} body Raw transaction conversion parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public async convertToPsbt(body: RequestsConvertToPSBTRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2005>> {
        return TransactionsApiFp(this.configuration).convertToPsbt(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a raw transaction spending the given inputs and creating new outputs. Note that the transaction's inputs are not signed, and it is not stored in the wallet or transmitted to the network.
     * @summary Create Raw Transaction
     * @param {RequestsCreateRawTxRequest} body Transaction parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public async createRawTransaction(body: RequestsCreateRawTxRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2005>> {
        return TransactionsApiFp(this.configuration).createRawTransaction(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Decodes a transaction and returns its inscriptions and runestone data
     * @summary Decode a transaction
     * @param {string} txid Transaction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public async decodeTx(txid: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20038>> {
        return TransactionsApiFp(this.configuration).decodeTx(txid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get raw transaction as a decoded object
     * @summary Get raw transaction (verbosity 1)
     * @param {string} txid Transaction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public async getRawTransactionDecoded(txid: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20039>> {
        return TransactionsApiFp(this.configuration).getRawTransactionDecoded(txid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get raw transaction as a raw hex string
     * @summary Get raw transaction (verbosity 0)
     * @param {string} txid Transaction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public async getRawTransactionHex(txid: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2005>> {
        return TransactionsApiFp(this.configuration).getRawTransactionHex(txid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get raw transaction with prevout information
     * @summary Get raw transaction (verbosity 2)
     * @param {string} txid Transaction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public async getRawTransactionPrevout(txid: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20040>> {
        return TransactionsApiFp(this.configuration).getRawTransactionPrevout(txid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve information about a specific transaction
     * @summary Get transaction info
     * @param {string} txid Transaction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public async getTransaction(txid: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20037>> {
        return TransactionsApiFp(this.configuration).getTransaction(txid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns details about an unspent transaction output
     * @summary Get transaction output
     * @param {RequestsGetTxOutRequest} body Transaction output request parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public async getTxOut(body: RequestsGetTxOutRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20033>> {
        return TransactionsApiFp(this.configuration).getTxOut(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a hex-encoded proof that one or more specified transactions were included in a block
     * @summary Get transaction output proof
     * @param {RequestsGetTxOutProofRequest} body Transaction proof request parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public async getTxOutProof(body: RequestsGetTxOutProofRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2005>> {
        return TransactionsApiFp(this.configuration).getTxOutProof(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns statistics about the unspent transaction output set
     * @summary Get transaction output set information
     * @param {RequestsGetTxOutSetInfoRequest} body UTXO set info request parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public async getTxOutSetInfo(body: RequestsGetTxOutSetInfoRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20034>> {
        return TransactionsApiFp(this.configuration).getTxOutSetInfo(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Scans the mempool to find transactions spending any of the given outputs
     * @summary Get transaction spending prevout
     * @param {RequestsGetTxSpendingPrevoutRequest} body Transaction spending prevout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public async getTxSpendingPrevout(body: RequestsGetTxSpendingPrevoutRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20036>> {
        return TransactionsApiFp(this.configuration).getTxSpendingPrevout(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Submits a raw transaction to local node and network
     * @summary Send raw transaction
     * @param {RequestsSendRawTransactionRequest} body Raw transaction to send
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public async sendRawTransaction(body: RequestsSendRawTransactionRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2005>> {
        return TransactionsApiFp(this.configuration).sendRawTransaction(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Verifies that a proof points to a transaction in a block
     * @summary Verify transaction output proof
     * @param {RequestsVerifyTxOutProofRequest} body Proof to verify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public async verifyTxOutProof(body: RequestsVerifyTxOutProofRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20035>> {
        return TransactionsApiFp(this.configuration).verifyTxOutProof(body, options).then((request) => request(this.axios, this.basePath));
    }
}
