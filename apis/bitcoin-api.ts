/* tslint:disable */
/* eslint-disable */
/**
 * Satstream API
 * Satstream API
 *
 * OpenAPI spec version: 1.0
 * Contact: team@satstream.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { GithubComSatstreamSsApiServerApiAddressResponsesError } from '../models';
import { GithubComSatstreamSsApiServerApiBlockResponsesError } from '../models';
import { GithubComSatstreamSsApiServerApiFeeResponsesError } from '../models';
import { GithubComSatstreamSsApiServerApiMempoolResponsesError } from '../models';
import { GithubComSatstreamSsApiServerApiMiningResponsesError } from '../models';
import { GithubComSatstreamSsApiServerApiNetworkResponsesError } from '../models';
import { GithubComSatstreamSsApiServerApiPsbtRequestsCreatePSBTRequest } from '../models';
import { GithubComSatstreamSsApiServerApiPsbtResponsesError } from '../models';
import { GithubComSatstreamSsApiServerApiScriptResponsesError } from '../models';
import { GithubComSatstreamSsApiServerApiTransactionRequestsCreatePSBTRequest } from '../models';
import { GithubComSatstreamSsApiServerApiTransactionResponsesError } from '../models';
import { RequestsAnalyzePSBTRequest } from '../models';
import { RequestsCombinePSBTRequest } from '../models';
import { RequestsCombineRawTransactionRequest } from '../models';
import { RequestsConvertToPSBTRequest } from '../models';
import { RequestsDecodeScriptRequest } from '../models';
import { RequestsEstimateRawFeeRequest } from '../models';
import { RequestsEstimateSmartFeeRequest } from '../models';
import { RequestsGetBlockStatsRequest } from '../models';
import { RequestsGetChainTxStatsRequest } from '../models';
import { RequestsGetMempoolAncestorsRequest } from '../models';
import { RequestsGetMempoolDescendantsRequest } from '../models';
import { RequestsGetNetworkHashPSRequest } from '../models';
import { RequestsGetRawMempoolRequest } from '../models';
import { RequestsGetTxOutProofRequest } from '../models';
import { RequestsGetTxOutRequest } from '../models';
import { RequestsGetTxOutSetInfoRequest } from '../models';
import { RequestsGetTxSpendingPrevoutRequest } from '../models';
import { RequestsJoinPSBTsRequest } from '../models';
import { RequestsSendRawTransactionRequest } from '../models';
import { RequestsTestMempoolAcceptRequest } from '../models';
import { RequestsVerifyMessageRequest } from '../models';
import { RequestsVerifyTxOutProofRequest } from '../models';
import { ResponsesAnalyzePSBTResponse } from '../models';
import { ResponsesCombinePSBTResponse } from '../models';
import { ResponsesCombineRawTransactionResponse } from '../models';
import { ResponsesConvertToPSBTResponse } from '../models';
import { ResponsesCreatePSBTResponse } from '../models';
import { ResponsesCreateRawTransactionResponse } from '../models';
import { ResponsesDecodePSBTResponse } from '../models';
import { ResponsesDecodeScriptResponse } from '../models';
import { ResponsesEstimateRawFeeResponse } from '../models';
import { ResponsesEstimateSmartFeeResponse } from '../models';
import { ResponsesGetBlockDecodedResponse } from '../models';
import { ResponsesGetBlockHexResponse } from '../models';
import { ResponsesGetBlockPrevoutResponse } from '../models';
import { ResponsesGetBlockStatsResponse } from '../models';
import { ResponsesGetBlockSummaryResponse } from '../models';
import { ResponsesGetBlockchainInfoResponse } from '../models';
import { ResponsesGetChainTxStatsResponse } from '../models';
import { ResponsesGetDifficultyResponse } from '../models';
import { ResponsesGetMempoolAncestorsResponse } from '../models';
import { ResponsesGetMempoolDescendantsResponse } from '../models';
import { ResponsesGetMempoolInfoResponse } from '../models';
import { ResponsesGetMiningInfoResponse } from '../models';
import { ResponsesGetNetworkHashPSResponse } from '../models';
import { ResponsesGetRawMempoolResponse } from '../models';
import { ResponsesGetRawTransactionDecodedResponse } from '../models';
import { ResponsesGetRawTransactionHexResponse } from '../models';
import { ResponsesGetRawTransactionPrevoutResponse } from '../models';
import { ResponsesGetTxOutProofResponse } from '../models';
import { ResponsesGetTxOutResponse } from '../models';
import { ResponsesGetTxOutSetInfoResponse } from '../models';
import { ResponsesGetTxSpendingPrevoutResponse } from '../models';
import { ResponsesJoinPSBTsResponse } from '../models';
import { ResponsesSendRawTransactionResponse } from '../models';
import { ResponsesTestMempoolAcceptResponse } from '../models';
import { ResponsesValidateAddressResponse } from '../models';
import { ResponsesVerifyMessageResponse } from '../models';
import { ResponsesVerifyTxOutProofResponse } from '../models';
/**
 * BitcoinApi - axios parameter creator
 * @export
 */
export const BitcoinApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Analyzes and provides information about the current status of a PSBT and its inputs
         * @summary Analyze PSBT
         * @param {RequestsAnalyzePSBTRequest} body PSBT to analyze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzePsbt: async (body: RequestsAnalyzePSBTRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling analyzePsbt.');
            }
            const localVarPath = `/psbt/analyze`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Combines multiple partially signed Bitcoin transactions into one transaction
         * @summary Combine PSBTs
         * @param {RequestsCombinePSBTRequest} body Array of PSBTs to combine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        combinePsbt: async (body: RequestsCombinePSBTRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling combinePsbt.');
            }
            const localVarPath = `/psbt/combine`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Combines multiple partially signed transactions into one transaction
         * @summary Combine Raw Transactions
         * @param {RequestsCombineRawTransactionRequest} body Array of hex-encoded raw transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        combineRawTransaction: async (body: RequestsCombineRawTransactionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling combineRawTransaction.');
            }
            const localVarPath = `/tx/combine`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction. createpsbt and walletcreatefundedpsbt should be used for new applications.
         * @summary Convert Raw Transaction to PSBT
         * @param {RequestsConvertToPSBTRequest} body Raw transaction conversion parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertToPsbt: async (body: RequestsConvertToPSBTRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling convertToPsbt.');
            }
            const localVarPath = `/tx/convert-to-psbt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a transaction in the Partially Signed Transaction format. Implements the Creator role.
         * @summary Create PSBT
         * @param {GithubComSatstreamSsApiServerApiPsbtRequestsCreatePSBTRequest} body Transaction parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPsbt: async (body: GithubComSatstreamSsApiServerApiPsbtRequestsCreatePSBTRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPsbt.');
            }
            const localVarPath = `/psbt/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a raw transaction spending the given inputs and creating new outputs. Note that the transaction's inputs are not signed, and it is not stored in the wallet or transmitted to the network.
         * @summary Create Raw Transaction
         * @param {GithubComSatstreamSsApiServerApiTransactionRequestsCreatePSBTRequest} body Transaction parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawTransaction: async (body: GithubComSatstreamSsApiServerApiTransactionRequestsCreatePSBTRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRawTransaction.');
            }
            const localVarPath = `/tx/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.
         * @summary Decode PSBT
         * @param {RequestsAnalyzePSBTRequest} body PSBT to decode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decodePsbt: async (body: RequestsAnalyzePSBTRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling decodePsbt.');
            }
            const localVarPath = `/psbt/decode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Decode a hex-encoded script and return detailed information about it.
         * @summary Decode Script
         * @param {RequestsDecodeScriptRequest} body Script to decode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decodeScript: async (body: RequestsDecodeScriptRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling decodeScript.');
            }
            const localVarPath = `/script/decode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Estimates the approximate fee per kilobyte needed for a transaction to begin confirmation within conf_target blocks if possible.
         * @summary Estimate Raw Fee
         * @param {RequestsEstimateRawFeeRequest} body Fee estimation parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateRawFee: async (body: RequestsEstimateRawFeeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling estimateRawFee.');
            }
            const localVarPath = `/fee/estimate-raw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Estimates the approximate fee per kilobyte needed for a transaction to begin confirmation within conf_target blocks
         * @summary Estimate smart fee
         * @param {RequestsEstimateSmartFeeRequest} body Fee estimation parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateSmartFee: async (body: RequestsEstimateSmartFeeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling estimateSmartFee.');
            }
            const localVarPath = `/fee/estimate-smart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get block by hash as a decoded object
         * @summary Get block by hash (verbosity 2)
         * @param {string} hash Block hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHashDecoded: async (hash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling getBlockByHashDecoded.');
            }
            const localVarPath = `/block/hash/{hash}/decoded`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get block by hash as a raw hex string
         * @summary Get block by hash (verbosity 0)
         * @param {string} hash Block hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHashHex: async (hash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling getBlockByHashHex.');
            }
            const localVarPath = `/block/hash/{hash}/hex`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get block by hash with prevout information
         * @summary Get block by hash (verbosity 3)
         * @param {string} hash Block hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHashPrevout: async (hash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling getBlockByHashPrevout.');
            }
            const localVarPath = `/block/hash/{hash}/prevout`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get block by hash as a summary object
         * @summary Get block by hash (verbosity 1)
         * @param {string} hash Block hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHashSummary: async (hash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling getBlockByHashSummary.');
            }
            const localVarPath = `/block/hash/{hash}/summary`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get block by height as a decoded object
         * @summary Get block by height (verbosity 2)
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHeightDecoded: async (height: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            if (height === null || height === undefined) {
                throw new RequiredError('height','Required parameter height was null or undefined when calling getBlockByHeightDecoded.');
            }
            const localVarPath = `/block/height/{height}/decoded`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get block by height as a raw hex string
         * @summary Get block by height (verbosity 0)
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHeightHex: async (height: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            if (height === null || height === undefined) {
                throw new RequiredError('height','Required parameter height was null or undefined when calling getBlockByHeightHex.');
            }
            const localVarPath = `/block/height/{height}/hex`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get block by height with prevout information
         * @summary Get block by height (verbosity 3)
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHeightPrevout: async (height: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            if (height === null || height === undefined) {
                throw new RequiredError('height','Required parameter height was null or undefined when calling getBlockByHeightPrevout.');
            }
            const localVarPath = `/block/height/{height}/prevout`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get block by height as a summary object
         * @summary Get block by height (verbosity 1)
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHeightSummary: async (height: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            if (height === null || height === undefined) {
                throw new RequiredError('height','Required parameter height was null or undefined when calling getBlockByHeightSummary.');
            }
            const localVarPath = `/block/height/{height}/summary`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Computes per block statistics for a given window
         * @summary Get block stats
         * @param {RequestsGetBlockStatsRequest} body Block stats request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockStats: async (body: RequestsGetBlockStatsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getBlockStats.');
            }
            const localVarPath = `/block/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object containing various state info regarding blockchain processing
         * @summary Get blockchain information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockchainInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/blockchain/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Computes statistics about the total number and rate of transactions in the chain
         * @summary Get chain tx stats
         * @param {RequestsGetChainTxStatsRequest} body Chain tx stats request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChainTxStats: async (body: RequestsGetChainTxStatsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getChainTxStats.');
            }
            const localVarPath = `/chain/txstats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the proof-of-work difficulty as a multiple of the minimum difficulty
         * @summary Get difficulty
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDifficulty: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/difficulty`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all in-mempool ancestors for a transaction in the mempool
         * @summary Get mempool ancestors
         * @param {RequestsGetMempoolAncestorsRequest} body Mempool ancestors request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMempoolAncestors: async (body: RequestsGetMempoolAncestorsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getMempoolAncestors.');
            }
            const localVarPath = `/mempool/ancestors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all in-mempool descendants for a transaction in the mempool
         * @summary Get mempool descendants
         * @param {RequestsGetMempoolDescendantsRequest} body Mempool descendants request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMempoolDescendants: async (body: RequestsGetMempoolDescendantsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getMempoolDescendants.');
            }
            const localVarPath = `/mempool/descendants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details on the active state of the TX memory pool
         * @summary Get mempool information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMempoolInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mempool/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a json object containing mining-related information
         * @summary Get mining information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mining/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the estimated network hashes per second based on the last n blocks
         * @summary Get network hash per second
         * @param {RequestsGetNetworkHashPSRequest} body Network hash rate parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkHashps: async (body: RequestsGetNetworkHashPSRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getNetworkHashps.');
            }
            const localVarPath = `/network/hashps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transaction ids in memory pool
         * @summary Get raw mempool
         * @param {RequestsGetRawMempoolRequest} body Raw mempool request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawMempool: async (body: RequestsGetRawMempoolRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getRawMempool.');
            }
            const localVarPath = `/mempool/raw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get raw transaction as a decoded object
         * @summary Get raw transaction (verbosity 1)
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawTransactionDecoded: async (txid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txid' is not null or undefined
            if (txid === null || txid === undefined) {
                throw new RequiredError('txid','Required parameter txid was null or undefined when calling getRawTransactionDecoded.');
            }
            const localVarPath = `/tx/{txid}/decoded`
                .replace(`{${"txid"}}`, encodeURIComponent(String(txid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get raw transaction as a raw hex string
         * @summary Get raw transaction (verbosity 0)
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawTransactionHex: async (txid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txid' is not null or undefined
            if (txid === null || txid === undefined) {
                throw new RequiredError('txid','Required parameter txid was null or undefined when calling getRawTransactionHex.');
            }
            const localVarPath = `/tx/{txid}/hex`
                .replace(`{${"txid"}}`, encodeURIComponent(String(txid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get raw transaction with prevout information
         * @summary Get raw transaction (verbosity 2)
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawTransactionPrevout: async (txid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txid' is not null or undefined
            if (txid === null || txid === undefined) {
                throw new RequiredError('txid','Required parameter txid was null or undefined when calling getRawTransactionPrevout.');
            }
            const localVarPath = `/tx/{txid}/prevout`
                .replace(`{${"txid"}}`, encodeURIComponent(String(txid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details about an unspent transaction output
         * @summary Get transaction output
         * @param {RequestsGetTxOutRequest} body Transaction output request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxOut: async (body: RequestsGetTxOutRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getTxOut.');
            }
            const localVarPath = `/tx/out`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a hex-encoded proof that one or more specified transactions were included in a block
         * @summary Get transaction output proof
         * @param {RequestsGetTxOutProofRequest} body Transaction proof request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxOutProof: async (body: RequestsGetTxOutProofRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getTxOutProof.');
            }
            const localVarPath = `/tx/out/proof`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns statistics about the unspent transaction output set
         * @summary Get transaction output set information
         * @param {RequestsGetTxOutSetInfoRequest} body UTXO set info request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxOutSetInfo: async (body: RequestsGetTxOutSetInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getTxOutSetInfo.');
            }
            const localVarPath = `/tx/out/set/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Scans the mempool to find transactions spending any of the given outputs
         * @summary Get transaction spending prevout
         * @param {RequestsGetTxSpendingPrevoutRequest} body Transaction spending prevout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxSpendingPrevout: async (body: RequestsGetTxSpendingPrevoutRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getTxSpendingPrevout.');
            }
            const localVarPath = `/tx/spending/prevout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Joins multiple distinct PSBTs with different inputs and outputs into one PSBT
         * @summary Join PSBTs
         * @param {RequestsJoinPSBTsRequest} body PSBTs to join
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinPsbts: async (body: RequestsJoinPSBTsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling joinPsbts.');
            }
            const localVarPath = `/psbt/join`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a raw transaction to local node and network
         * @summary Send raw transaction
         * @param {RequestsSendRawTransactionRequest} body Raw transaction to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRawTransaction: async (body: RequestsSendRawTransactionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendRawTransaction.');
            }
            const localVarPath = `/tx/send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Tests whether raw transactions would be accepted by mempool
         * @summary Test mempool accept
         * @param {RequestsTestMempoolAcceptRequest} body Raw transactions to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testMempoolAccept: async (body: RequestsTestMempoolAcceptRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling testMempoolAccept.');
            }
            const localVarPath = `/mempool/test-accept`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the given Bitcoin address
         * @summary Validate address
         * @param {string} address Bitcoin address to validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAddress: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling validateAddress.');
            }
            const localVarPath = `/address/{address}/validate`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies a signed message
         * @summary Verify message
         * @param {RequestsVerifyMessageRequest} body Message verification parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyMessage: async (body: RequestsVerifyMessageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling verifyMessage.');
            }
            const localVarPath = `/address/verify-message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies that a proof points to a transaction in a block
         * @summary Verify transaction output proof
         * @param {RequestsVerifyTxOutProofRequest} body Proof to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyTxOutProof: async (body: RequestsVerifyTxOutProofRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling verifyTxOutProof.');
            }
            const localVarPath = `/tx/out/proof/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BitcoinApi - functional programming interface
 * @export
 */
export const BitcoinApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Analyzes and provides information about the current status of a PSBT and its inputs
         * @summary Analyze PSBT
         * @param {RequestsAnalyzePSBTRequest} body PSBT to analyze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyzePsbt(body: RequestsAnalyzePSBTRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesAnalyzePSBTResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).analyzePsbt(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Combines multiple partially signed Bitcoin transactions into one transaction
         * @summary Combine PSBTs
         * @param {RequestsCombinePSBTRequest} body Array of PSBTs to combine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async combinePsbt(body: RequestsCombinePSBTRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesCombinePSBTResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).combinePsbt(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Combines multiple partially signed transactions into one transaction
         * @summary Combine Raw Transactions
         * @param {RequestsCombineRawTransactionRequest} body Array of hex-encoded raw transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async combineRawTransaction(body: RequestsCombineRawTransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesCombineRawTransactionResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).combineRawTransaction(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Converts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction. createpsbt and walletcreatefundedpsbt should be used for new applications.
         * @summary Convert Raw Transaction to PSBT
         * @param {RequestsConvertToPSBTRequest} body Raw transaction conversion parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async convertToPsbt(body: RequestsConvertToPSBTRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesConvertToPSBTResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).convertToPsbt(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a transaction in the Partially Signed Transaction format. Implements the Creator role.
         * @summary Create PSBT
         * @param {GithubComSatstreamSsApiServerApiPsbtRequestsCreatePSBTRequest} body Transaction parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPsbt(body: GithubComSatstreamSsApiServerApiPsbtRequestsCreatePSBTRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesCreatePSBTResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).createPsbt(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a raw transaction spending the given inputs and creating new outputs. Note that the transaction's inputs are not signed, and it is not stored in the wallet or transmitted to the network.
         * @summary Create Raw Transaction
         * @param {GithubComSatstreamSsApiServerApiTransactionRequestsCreatePSBTRequest} body Transaction parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRawTransaction(body: GithubComSatstreamSsApiServerApiTransactionRequestsCreatePSBTRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesCreateRawTransactionResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).createRawTransaction(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.
         * @summary Decode PSBT
         * @param {RequestsAnalyzePSBTRequest} body PSBT to decode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async decodePsbt(body: RequestsAnalyzePSBTRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesDecodePSBTResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).decodePsbt(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Decode a hex-encoded script and return detailed information about it.
         * @summary Decode Script
         * @param {RequestsDecodeScriptRequest} body Script to decode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async decodeScript(body: RequestsDecodeScriptRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesDecodeScriptResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).decodeScript(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Estimates the approximate fee per kilobyte needed for a transaction to begin confirmation within conf_target blocks if possible.
         * @summary Estimate Raw Fee
         * @param {RequestsEstimateRawFeeRequest} body Fee estimation parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async estimateRawFee(body: RequestsEstimateRawFeeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesEstimateRawFeeResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).estimateRawFee(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Estimates the approximate fee per kilobyte needed for a transaction to begin confirmation within conf_target blocks
         * @summary Estimate smart fee
         * @param {RequestsEstimateSmartFeeRequest} body Fee estimation parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async estimateSmartFee(body: RequestsEstimateSmartFeeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesEstimateSmartFeeResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).estimateSmartFee(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get block by hash as a decoded object
         * @summary Get block by hash (verbosity 2)
         * @param {string} hash Block hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockByHashDecoded(hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetBlockDecodedResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getBlockByHashDecoded(hash, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get block by hash as a raw hex string
         * @summary Get block by hash (verbosity 0)
         * @param {string} hash Block hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockByHashHex(hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetBlockHexResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getBlockByHashHex(hash, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get block by hash with prevout information
         * @summary Get block by hash (verbosity 3)
         * @param {string} hash Block hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockByHashPrevout(hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetBlockPrevoutResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getBlockByHashPrevout(hash, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get block by hash as a summary object
         * @summary Get block by hash (verbosity 1)
         * @param {string} hash Block hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockByHashSummary(hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetBlockSummaryResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getBlockByHashSummary(hash, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get block by height as a decoded object
         * @summary Get block by height (verbosity 2)
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockByHeightDecoded(height: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetBlockDecodedResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getBlockByHeightDecoded(height, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get block by height as a raw hex string
         * @summary Get block by height (verbosity 0)
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockByHeightHex(height: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetBlockHexResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getBlockByHeightHex(height, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get block by height with prevout information
         * @summary Get block by height (verbosity 3)
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockByHeightPrevout(height: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetBlockPrevoutResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getBlockByHeightPrevout(height, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get block by height as a summary object
         * @summary Get block by height (verbosity 1)
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockByHeightSummary(height: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetBlockSummaryResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getBlockByHeightSummary(height, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Computes per block statistics for a given window
         * @summary Get block stats
         * @param {RequestsGetBlockStatsRequest} body Block stats request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockStats(body: RequestsGetBlockStatsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetBlockStatsResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getBlockStats(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an object containing various state info regarding blockchain processing
         * @summary Get blockchain information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockchainInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetBlockchainInfoResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getBlockchainInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Computes statistics about the total number and rate of transactions in the chain
         * @summary Get chain tx stats
         * @param {RequestsGetChainTxStatsRequest} body Chain tx stats request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChainTxStats(body: RequestsGetChainTxStatsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetChainTxStatsResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getChainTxStats(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the proof-of-work difficulty as a multiple of the minimum difficulty
         * @summary Get difficulty
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDifficulty(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetDifficultyResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getDifficulty(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns all in-mempool ancestors for a transaction in the mempool
         * @summary Get mempool ancestors
         * @param {RequestsGetMempoolAncestorsRequest} body Mempool ancestors request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMempoolAncestors(body: RequestsGetMempoolAncestorsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetMempoolAncestorsResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getMempoolAncestors(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns all in-mempool descendants for a transaction in the mempool
         * @summary Get mempool descendants
         * @param {RequestsGetMempoolDescendantsRequest} body Mempool descendants request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMempoolDescendants(body: RequestsGetMempoolDescendantsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetMempoolDescendantsResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getMempoolDescendants(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns details on the active state of the TX memory pool
         * @summary Get mempool information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMempoolInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetMempoolInfoResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getMempoolInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a json object containing mining-related information
         * @summary Get mining information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMiningInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetMiningInfoResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getMiningInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the estimated network hashes per second based on the last n blocks
         * @summary Get network hash per second
         * @param {RequestsGetNetworkHashPSRequest} body Network hash rate parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkHashps(body: RequestsGetNetworkHashPSRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetNetworkHashPSResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getNetworkHashps(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns all transaction ids in memory pool
         * @summary Get raw mempool
         * @param {RequestsGetRawMempoolRequest} body Raw mempool request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawMempool(body: RequestsGetRawMempoolRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetRawMempoolResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getRawMempool(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get raw transaction as a decoded object
         * @summary Get raw transaction (verbosity 1)
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawTransactionDecoded(txid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetRawTransactionDecodedResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getRawTransactionDecoded(txid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get raw transaction as a raw hex string
         * @summary Get raw transaction (verbosity 0)
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawTransactionHex(txid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetRawTransactionHexResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getRawTransactionHex(txid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get raw transaction with prevout information
         * @summary Get raw transaction (verbosity 2)
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawTransactionPrevout(txid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetRawTransactionPrevoutResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getRawTransactionPrevout(txid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns details about an unspent transaction output
         * @summary Get transaction output
         * @param {RequestsGetTxOutRequest} body Transaction output request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxOut(body: RequestsGetTxOutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetTxOutResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getTxOut(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a hex-encoded proof that one or more specified transactions were included in a block
         * @summary Get transaction output proof
         * @param {RequestsGetTxOutProofRequest} body Transaction proof request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxOutProof(body: RequestsGetTxOutProofRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetTxOutProofResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getTxOutProof(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns statistics about the unspent transaction output set
         * @summary Get transaction output set information
         * @param {RequestsGetTxOutSetInfoRequest} body UTXO set info request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxOutSetInfo(body: RequestsGetTxOutSetInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetTxOutSetInfoResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getTxOutSetInfo(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Scans the mempool to find transactions spending any of the given outputs
         * @summary Get transaction spending prevout
         * @param {RequestsGetTxSpendingPrevoutRequest} body Transaction spending prevout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxSpendingPrevout(body: RequestsGetTxSpendingPrevoutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesGetTxSpendingPrevoutResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).getTxSpendingPrevout(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Joins multiple distinct PSBTs with different inputs and outputs into one PSBT
         * @summary Join PSBTs
         * @param {RequestsJoinPSBTsRequest} body PSBTs to join
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinPsbts(body: RequestsJoinPSBTsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesJoinPSBTsResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).joinPsbts(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Submits a raw transaction to local node and network
         * @summary Send raw transaction
         * @param {RequestsSendRawTransactionRequest} body Raw transaction to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendRawTransaction(body: RequestsSendRawTransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesSendRawTransactionResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).sendRawTransaction(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Tests whether raw transactions would be accepted by mempool
         * @summary Test mempool accept
         * @param {RequestsTestMempoolAcceptRequest} body Raw transactions to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testMempoolAccept(body: RequestsTestMempoolAcceptRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesTestMempoolAcceptResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).testMempoolAccept(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns information about the given Bitcoin address
         * @summary Validate address
         * @param {string} address Bitcoin address to validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateAddress(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesValidateAddressResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).validateAddress(address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Verifies a signed message
         * @summary Verify message
         * @param {RequestsVerifyMessageRequest} body Message verification parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyMessage(body: RequestsVerifyMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesVerifyMessageResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).verifyMessage(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Verifies that a proof points to a transaction in a block
         * @summary Verify transaction output proof
         * @param {RequestsVerifyTxOutProofRequest} body Proof to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyTxOutProof(body: RequestsVerifyTxOutProofRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResponsesVerifyTxOutProofResponse>>> {
            const localVarAxiosArgs = await BitcoinApiAxiosParamCreator(configuration).verifyTxOutProof(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BitcoinApi - factory interface
 * @export
 */
export const BitcoinApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Analyzes and provides information about the current status of a PSBT and its inputs
         * @summary Analyze PSBT
         * @param {RequestsAnalyzePSBTRequest} body PSBT to analyze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyzePsbt(body: RequestsAnalyzePSBTRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesAnalyzePSBTResponse>> {
            return BitcoinApiFp(configuration).analyzePsbt(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Combines multiple partially signed Bitcoin transactions into one transaction
         * @summary Combine PSBTs
         * @param {RequestsCombinePSBTRequest} body Array of PSBTs to combine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async combinePsbt(body: RequestsCombinePSBTRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesCombinePSBTResponse>> {
            return BitcoinApiFp(configuration).combinePsbt(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Combines multiple partially signed transactions into one transaction
         * @summary Combine Raw Transactions
         * @param {RequestsCombineRawTransactionRequest} body Array of hex-encoded raw transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async combineRawTransaction(body: RequestsCombineRawTransactionRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesCombineRawTransactionResponse>> {
            return BitcoinApiFp(configuration).combineRawTransaction(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Converts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction. createpsbt and walletcreatefundedpsbt should be used for new applications.
         * @summary Convert Raw Transaction to PSBT
         * @param {RequestsConvertToPSBTRequest} body Raw transaction conversion parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async convertToPsbt(body: RequestsConvertToPSBTRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesConvertToPSBTResponse>> {
            return BitcoinApiFp(configuration).convertToPsbt(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a transaction in the Partially Signed Transaction format. Implements the Creator role.
         * @summary Create PSBT
         * @param {GithubComSatstreamSsApiServerApiPsbtRequestsCreatePSBTRequest} body Transaction parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPsbt(body: GithubComSatstreamSsApiServerApiPsbtRequestsCreatePSBTRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesCreatePSBTResponse>> {
            return BitcoinApiFp(configuration).createPsbt(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a raw transaction spending the given inputs and creating new outputs. Note that the transaction's inputs are not signed, and it is not stored in the wallet or transmitted to the network.
         * @summary Create Raw Transaction
         * @param {GithubComSatstreamSsApiServerApiTransactionRequestsCreatePSBTRequest} body Transaction parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRawTransaction(body: GithubComSatstreamSsApiServerApiTransactionRequestsCreatePSBTRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesCreateRawTransactionResponse>> {
            return BitcoinApiFp(configuration).createRawTransaction(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.
         * @summary Decode PSBT
         * @param {RequestsAnalyzePSBTRequest} body PSBT to decode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async decodePsbt(body: RequestsAnalyzePSBTRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesDecodePSBTResponse>> {
            return BitcoinApiFp(configuration).decodePsbt(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Decode a hex-encoded script and return detailed information about it.
         * @summary Decode Script
         * @param {RequestsDecodeScriptRequest} body Script to decode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async decodeScript(body: RequestsDecodeScriptRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesDecodeScriptResponse>> {
            return BitcoinApiFp(configuration).decodeScript(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Estimates the approximate fee per kilobyte needed for a transaction to begin confirmation within conf_target blocks if possible.
         * @summary Estimate Raw Fee
         * @param {RequestsEstimateRawFeeRequest} body Fee estimation parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async estimateRawFee(body: RequestsEstimateRawFeeRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesEstimateRawFeeResponse>> {
            return BitcoinApiFp(configuration).estimateRawFee(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Estimates the approximate fee per kilobyte needed for a transaction to begin confirmation within conf_target blocks
         * @summary Estimate smart fee
         * @param {RequestsEstimateSmartFeeRequest} body Fee estimation parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async estimateSmartFee(body: RequestsEstimateSmartFeeRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesEstimateSmartFeeResponse>> {
            return BitcoinApiFp(configuration).estimateSmartFee(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get block by hash as a decoded object
         * @summary Get block by hash (verbosity 2)
         * @param {string} hash Block hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockByHashDecoded(hash: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetBlockDecodedResponse>> {
            return BitcoinApiFp(configuration).getBlockByHashDecoded(hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Get block by hash as a raw hex string
         * @summary Get block by hash (verbosity 0)
         * @param {string} hash Block hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockByHashHex(hash: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetBlockHexResponse>> {
            return BitcoinApiFp(configuration).getBlockByHashHex(hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Get block by hash with prevout information
         * @summary Get block by hash (verbosity 3)
         * @param {string} hash Block hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockByHashPrevout(hash: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetBlockPrevoutResponse>> {
            return BitcoinApiFp(configuration).getBlockByHashPrevout(hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Get block by hash as a summary object
         * @summary Get block by hash (verbosity 1)
         * @param {string} hash Block hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockByHashSummary(hash: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetBlockSummaryResponse>> {
            return BitcoinApiFp(configuration).getBlockByHashSummary(hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Get block by height as a decoded object
         * @summary Get block by height (verbosity 2)
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockByHeightDecoded(height: number, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetBlockDecodedResponse>> {
            return BitcoinApiFp(configuration).getBlockByHeightDecoded(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Get block by height as a raw hex string
         * @summary Get block by height (verbosity 0)
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockByHeightHex(height: number, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetBlockHexResponse>> {
            return BitcoinApiFp(configuration).getBlockByHeightHex(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Get block by height with prevout information
         * @summary Get block by height (verbosity 3)
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockByHeightPrevout(height: number, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetBlockPrevoutResponse>> {
            return BitcoinApiFp(configuration).getBlockByHeightPrevout(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Get block by height as a summary object
         * @summary Get block by height (verbosity 1)
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockByHeightSummary(height: number, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetBlockSummaryResponse>> {
            return BitcoinApiFp(configuration).getBlockByHeightSummary(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Computes per block statistics for a given window
         * @summary Get block stats
         * @param {RequestsGetBlockStatsRequest} body Block stats request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockStats(body: RequestsGetBlockStatsRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetBlockStatsResponse>> {
            return BitcoinApiFp(configuration).getBlockStats(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object containing various state info regarding blockchain processing
         * @summary Get blockchain information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockchainInfo(options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetBlockchainInfoResponse>> {
            return BitcoinApiFp(configuration).getBlockchainInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Computes statistics about the total number and rate of transactions in the chain
         * @summary Get chain tx stats
         * @param {RequestsGetChainTxStatsRequest} body Chain tx stats request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChainTxStats(body: RequestsGetChainTxStatsRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetChainTxStatsResponse>> {
            return BitcoinApiFp(configuration).getChainTxStats(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the proof-of-work difficulty as a multiple of the minimum difficulty
         * @summary Get difficulty
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDifficulty(options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetDifficultyResponse>> {
            return BitcoinApiFp(configuration).getDifficulty(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all in-mempool ancestors for a transaction in the mempool
         * @summary Get mempool ancestors
         * @param {RequestsGetMempoolAncestorsRequest} body Mempool ancestors request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMempoolAncestors(body: RequestsGetMempoolAncestorsRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetMempoolAncestorsResponse>> {
            return BitcoinApiFp(configuration).getMempoolAncestors(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all in-mempool descendants for a transaction in the mempool
         * @summary Get mempool descendants
         * @param {RequestsGetMempoolDescendantsRequest} body Mempool descendants request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMempoolDescendants(body: RequestsGetMempoolDescendantsRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetMempoolDescendantsResponse>> {
            return BitcoinApiFp(configuration).getMempoolDescendants(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns details on the active state of the TX memory pool
         * @summary Get mempool information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMempoolInfo(options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetMempoolInfoResponse>> {
            return BitcoinApiFp(configuration).getMempoolInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a json object containing mining-related information
         * @summary Get mining information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMiningInfo(options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetMiningInfoResponse>> {
            return BitcoinApiFp(configuration).getMiningInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the estimated network hashes per second based on the last n blocks
         * @summary Get network hash per second
         * @param {RequestsGetNetworkHashPSRequest} body Network hash rate parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkHashps(body: RequestsGetNetworkHashPSRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetNetworkHashPSResponse>> {
            return BitcoinApiFp(configuration).getNetworkHashps(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all transaction ids in memory pool
         * @summary Get raw mempool
         * @param {RequestsGetRawMempoolRequest} body Raw mempool request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawMempool(body: RequestsGetRawMempoolRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetRawMempoolResponse>> {
            return BitcoinApiFp(configuration).getRawMempool(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get raw transaction as a decoded object
         * @summary Get raw transaction (verbosity 1)
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawTransactionDecoded(txid: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetRawTransactionDecodedResponse>> {
            return BitcoinApiFp(configuration).getRawTransactionDecoded(txid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get raw transaction as a raw hex string
         * @summary Get raw transaction (verbosity 0)
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawTransactionHex(txid: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetRawTransactionHexResponse>> {
            return BitcoinApiFp(configuration).getRawTransactionHex(txid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get raw transaction with prevout information
         * @summary Get raw transaction (verbosity 2)
         * @param {string} txid Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawTransactionPrevout(txid: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetRawTransactionPrevoutResponse>> {
            return BitcoinApiFp(configuration).getRawTransactionPrevout(txid, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns details about an unspent transaction output
         * @summary Get transaction output
         * @param {RequestsGetTxOutRequest} body Transaction output request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxOut(body: RequestsGetTxOutRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetTxOutResponse>> {
            return BitcoinApiFp(configuration).getTxOut(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a hex-encoded proof that one or more specified transactions were included in a block
         * @summary Get transaction output proof
         * @param {RequestsGetTxOutProofRequest} body Transaction proof request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxOutProof(body: RequestsGetTxOutProofRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetTxOutProofResponse>> {
            return BitcoinApiFp(configuration).getTxOutProof(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns statistics about the unspent transaction output set
         * @summary Get transaction output set information
         * @param {RequestsGetTxOutSetInfoRequest} body UTXO set info request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxOutSetInfo(body: RequestsGetTxOutSetInfoRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetTxOutSetInfoResponse>> {
            return BitcoinApiFp(configuration).getTxOutSetInfo(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Scans the mempool to find transactions spending any of the given outputs
         * @summary Get transaction spending prevout
         * @param {RequestsGetTxSpendingPrevoutRequest} body Transaction spending prevout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxSpendingPrevout(body: RequestsGetTxSpendingPrevoutRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesGetTxSpendingPrevoutResponse>> {
            return BitcoinApiFp(configuration).getTxSpendingPrevout(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Joins multiple distinct PSBTs with different inputs and outputs into one PSBT
         * @summary Join PSBTs
         * @param {RequestsJoinPSBTsRequest} body PSBTs to join
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinPsbts(body: RequestsJoinPSBTsRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesJoinPSBTsResponse>> {
            return BitcoinApiFp(configuration).joinPsbts(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits a raw transaction to local node and network
         * @summary Send raw transaction
         * @param {RequestsSendRawTransactionRequest} body Raw transaction to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendRawTransaction(body: RequestsSendRawTransactionRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesSendRawTransactionResponse>> {
            return BitcoinApiFp(configuration).sendRawTransaction(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Tests whether raw transactions would be accepted by mempool
         * @summary Test mempool accept
         * @param {RequestsTestMempoolAcceptRequest} body Raw transactions to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testMempoolAccept(body: RequestsTestMempoolAcceptRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesTestMempoolAcceptResponse>> {
            return BitcoinApiFp(configuration).testMempoolAccept(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the given Bitcoin address
         * @summary Validate address
         * @param {string} address Bitcoin address to validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateAddress(address: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesValidateAddressResponse>> {
            return BitcoinApiFp(configuration).validateAddress(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies a signed message
         * @summary Verify message
         * @param {RequestsVerifyMessageRequest} body Message verification parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyMessage(body: RequestsVerifyMessageRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesVerifyMessageResponse>> {
            return BitcoinApiFp(configuration).verifyMessage(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies that a proof points to a transaction in a block
         * @summary Verify transaction output proof
         * @param {RequestsVerifyTxOutProofRequest} body Proof to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyTxOutProof(body: RequestsVerifyTxOutProofRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ResponsesVerifyTxOutProofResponse>> {
            return BitcoinApiFp(configuration).verifyTxOutProof(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BitcoinApi - object-oriented interface
 * @export
 * @class BitcoinApi
 * @extends {BaseAPI}
 */
export class BitcoinApi extends BaseAPI {
    /**
     * Analyzes and provides information about the current status of a PSBT and its inputs
     * @summary Analyze PSBT
     * @param {RequestsAnalyzePSBTRequest} body PSBT to analyze
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async analyzePsbt(body: RequestsAnalyzePSBTRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesAnalyzePSBTResponse>> {
        return BitcoinApiFp(this.configuration).analyzePsbt(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Combines multiple partially signed Bitcoin transactions into one transaction
     * @summary Combine PSBTs
     * @param {RequestsCombinePSBTRequest} body Array of PSBTs to combine
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async combinePsbt(body: RequestsCombinePSBTRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesCombinePSBTResponse>> {
        return BitcoinApiFp(this.configuration).combinePsbt(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Combines multiple partially signed transactions into one transaction
     * @summary Combine Raw Transactions
     * @param {RequestsCombineRawTransactionRequest} body Array of hex-encoded raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async combineRawTransaction(body: RequestsCombineRawTransactionRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesCombineRawTransactionResponse>> {
        return BitcoinApiFp(this.configuration).combineRawTransaction(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Converts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction. createpsbt and walletcreatefundedpsbt should be used for new applications.
     * @summary Convert Raw Transaction to PSBT
     * @param {RequestsConvertToPSBTRequest} body Raw transaction conversion parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async convertToPsbt(body: RequestsConvertToPSBTRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesConvertToPSBTResponse>> {
        return BitcoinApiFp(this.configuration).convertToPsbt(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a transaction in the Partially Signed Transaction format. Implements the Creator role.
     * @summary Create PSBT
     * @param {GithubComSatstreamSsApiServerApiPsbtRequestsCreatePSBTRequest} body Transaction parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async createPsbt(body: GithubComSatstreamSsApiServerApiPsbtRequestsCreatePSBTRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesCreatePSBTResponse>> {
        return BitcoinApiFp(this.configuration).createPsbt(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a raw transaction spending the given inputs and creating new outputs. Note that the transaction's inputs are not signed, and it is not stored in the wallet or transmitted to the network.
     * @summary Create Raw Transaction
     * @param {GithubComSatstreamSsApiServerApiTransactionRequestsCreatePSBTRequest} body Transaction parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async createRawTransaction(body: GithubComSatstreamSsApiServerApiTransactionRequestsCreatePSBTRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesCreateRawTransactionResponse>> {
        return BitcoinApiFp(this.configuration).createRawTransaction(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Return a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.
     * @summary Decode PSBT
     * @param {RequestsAnalyzePSBTRequest} body PSBT to decode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async decodePsbt(body: RequestsAnalyzePSBTRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesDecodePSBTResponse>> {
        return BitcoinApiFp(this.configuration).decodePsbt(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Decode a hex-encoded script and return detailed information about it.
     * @summary Decode Script
     * @param {RequestsDecodeScriptRequest} body Script to decode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async decodeScript(body: RequestsDecodeScriptRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesDecodeScriptResponse>> {
        return BitcoinApiFp(this.configuration).decodeScript(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Estimates the approximate fee per kilobyte needed for a transaction to begin confirmation within conf_target blocks if possible.
     * @summary Estimate Raw Fee
     * @param {RequestsEstimateRawFeeRequest} body Fee estimation parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async estimateRawFee(body: RequestsEstimateRawFeeRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesEstimateRawFeeResponse>> {
        return BitcoinApiFp(this.configuration).estimateRawFee(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Estimates the approximate fee per kilobyte needed for a transaction to begin confirmation within conf_target blocks
     * @summary Estimate smart fee
     * @param {RequestsEstimateSmartFeeRequest} body Fee estimation parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async estimateSmartFee(body: RequestsEstimateSmartFeeRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesEstimateSmartFeeResponse>> {
        return BitcoinApiFp(this.configuration).estimateSmartFee(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get block by hash as a decoded object
     * @summary Get block by hash (verbosity 2)
     * @param {string} hash Block hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getBlockByHashDecoded(hash: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetBlockDecodedResponse>> {
        return BitcoinApiFp(this.configuration).getBlockByHashDecoded(hash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get block by hash as a raw hex string
     * @summary Get block by hash (verbosity 0)
     * @param {string} hash Block hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getBlockByHashHex(hash: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetBlockHexResponse>> {
        return BitcoinApiFp(this.configuration).getBlockByHashHex(hash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get block by hash with prevout information
     * @summary Get block by hash (verbosity 3)
     * @param {string} hash Block hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getBlockByHashPrevout(hash: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetBlockPrevoutResponse>> {
        return BitcoinApiFp(this.configuration).getBlockByHashPrevout(hash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get block by hash as a summary object
     * @summary Get block by hash (verbosity 1)
     * @param {string} hash Block hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getBlockByHashSummary(hash: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetBlockSummaryResponse>> {
        return BitcoinApiFp(this.configuration).getBlockByHashSummary(hash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get block by height as a decoded object
     * @summary Get block by height (verbosity 2)
     * @param {number} height Block height
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getBlockByHeightDecoded(height: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetBlockDecodedResponse>> {
        return BitcoinApiFp(this.configuration).getBlockByHeightDecoded(height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get block by height as a raw hex string
     * @summary Get block by height (verbosity 0)
     * @param {number} height Block height
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getBlockByHeightHex(height: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetBlockHexResponse>> {
        return BitcoinApiFp(this.configuration).getBlockByHeightHex(height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get block by height with prevout information
     * @summary Get block by height (verbosity 3)
     * @param {number} height Block height
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getBlockByHeightPrevout(height: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetBlockPrevoutResponse>> {
        return BitcoinApiFp(this.configuration).getBlockByHeightPrevout(height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get block by height as a summary object
     * @summary Get block by height (verbosity 1)
     * @param {number} height Block height
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getBlockByHeightSummary(height: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetBlockSummaryResponse>> {
        return BitcoinApiFp(this.configuration).getBlockByHeightSummary(height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Computes per block statistics for a given window
     * @summary Get block stats
     * @param {RequestsGetBlockStatsRequest} body Block stats request parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getBlockStats(body: RequestsGetBlockStatsRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetBlockStatsResponse>> {
        return BitcoinApiFp(this.configuration).getBlockStats(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an object containing various state info regarding blockchain processing
     * @summary Get blockchain information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getBlockchainInfo(options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetBlockchainInfoResponse>> {
        return BitcoinApiFp(this.configuration).getBlockchainInfo(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Computes statistics about the total number and rate of transactions in the chain
     * @summary Get chain tx stats
     * @param {RequestsGetChainTxStatsRequest} body Chain tx stats request parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getChainTxStats(body: RequestsGetChainTxStatsRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetChainTxStatsResponse>> {
        return BitcoinApiFp(this.configuration).getChainTxStats(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the proof-of-work difficulty as a multiple of the minimum difficulty
     * @summary Get difficulty
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getDifficulty(options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetDifficultyResponse>> {
        return BitcoinApiFp(this.configuration).getDifficulty(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all in-mempool ancestors for a transaction in the mempool
     * @summary Get mempool ancestors
     * @param {RequestsGetMempoolAncestorsRequest} body Mempool ancestors request parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getMempoolAncestors(body: RequestsGetMempoolAncestorsRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetMempoolAncestorsResponse>> {
        return BitcoinApiFp(this.configuration).getMempoolAncestors(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all in-mempool descendants for a transaction in the mempool
     * @summary Get mempool descendants
     * @param {RequestsGetMempoolDescendantsRequest} body Mempool descendants request parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getMempoolDescendants(body: RequestsGetMempoolDescendantsRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetMempoolDescendantsResponse>> {
        return BitcoinApiFp(this.configuration).getMempoolDescendants(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns details on the active state of the TX memory pool
     * @summary Get mempool information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getMempoolInfo(options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetMempoolInfoResponse>> {
        return BitcoinApiFp(this.configuration).getMempoolInfo(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a json object containing mining-related information
     * @summary Get mining information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getMiningInfo(options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetMiningInfoResponse>> {
        return BitcoinApiFp(this.configuration).getMiningInfo(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the estimated network hashes per second based on the last n blocks
     * @summary Get network hash per second
     * @param {RequestsGetNetworkHashPSRequest} body Network hash rate parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getNetworkHashps(body: RequestsGetNetworkHashPSRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetNetworkHashPSResponse>> {
        return BitcoinApiFp(this.configuration).getNetworkHashps(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all transaction ids in memory pool
     * @summary Get raw mempool
     * @param {RequestsGetRawMempoolRequest} body Raw mempool request parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getRawMempool(body: RequestsGetRawMempoolRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetRawMempoolResponse>> {
        return BitcoinApiFp(this.configuration).getRawMempool(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get raw transaction as a decoded object
     * @summary Get raw transaction (verbosity 1)
     * @param {string} txid Transaction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getRawTransactionDecoded(txid: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetRawTransactionDecodedResponse>> {
        return BitcoinApiFp(this.configuration).getRawTransactionDecoded(txid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get raw transaction as a raw hex string
     * @summary Get raw transaction (verbosity 0)
     * @param {string} txid Transaction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getRawTransactionHex(txid: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetRawTransactionHexResponse>> {
        return BitcoinApiFp(this.configuration).getRawTransactionHex(txid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get raw transaction with prevout information
     * @summary Get raw transaction (verbosity 2)
     * @param {string} txid Transaction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getRawTransactionPrevout(txid: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetRawTransactionPrevoutResponse>> {
        return BitcoinApiFp(this.configuration).getRawTransactionPrevout(txid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns details about an unspent transaction output
     * @summary Get transaction output
     * @param {RequestsGetTxOutRequest} body Transaction output request parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getTxOut(body: RequestsGetTxOutRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetTxOutResponse>> {
        return BitcoinApiFp(this.configuration).getTxOut(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a hex-encoded proof that one or more specified transactions were included in a block
     * @summary Get transaction output proof
     * @param {RequestsGetTxOutProofRequest} body Transaction proof request parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getTxOutProof(body: RequestsGetTxOutProofRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetTxOutProofResponse>> {
        return BitcoinApiFp(this.configuration).getTxOutProof(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns statistics about the unspent transaction output set
     * @summary Get transaction output set information
     * @param {RequestsGetTxOutSetInfoRequest} body UTXO set info request parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getTxOutSetInfo(body: RequestsGetTxOutSetInfoRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetTxOutSetInfoResponse>> {
        return BitcoinApiFp(this.configuration).getTxOutSetInfo(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Scans the mempool to find transactions spending any of the given outputs
     * @summary Get transaction spending prevout
     * @param {RequestsGetTxSpendingPrevoutRequest} body Transaction spending prevout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async getTxSpendingPrevout(body: RequestsGetTxSpendingPrevoutRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesGetTxSpendingPrevoutResponse>> {
        return BitcoinApiFp(this.configuration).getTxSpendingPrevout(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Joins multiple distinct PSBTs with different inputs and outputs into one PSBT
     * @summary Join PSBTs
     * @param {RequestsJoinPSBTsRequest} body PSBTs to join
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async joinPsbts(body: RequestsJoinPSBTsRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesJoinPSBTsResponse>> {
        return BitcoinApiFp(this.configuration).joinPsbts(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Submits a raw transaction to local node and network
     * @summary Send raw transaction
     * @param {RequestsSendRawTransactionRequest} body Raw transaction to send
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async sendRawTransaction(body: RequestsSendRawTransactionRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesSendRawTransactionResponse>> {
        return BitcoinApiFp(this.configuration).sendRawTransaction(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Tests whether raw transactions would be accepted by mempool
     * @summary Test mempool accept
     * @param {RequestsTestMempoolAcceptRequest} body Raw transactions to test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async testMempoolAccept(body: RequestsTestMempoolAcceptRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesTestMempoolAcceptResponse>> {
        return BitcoinApiFp(this.configuration).testMempoolAccept(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns information about the given Bitcoin address
     * @summary Validate address
     * @param {string} address Bitcoin address to validate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async validateAddress(address: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesValidateAddressResponse>> {
        return BitcoinApiFp(this.configuration).validateAddress(address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Verifies a signed message
     * @summary Verify message
     * @param {RequestsVerifyMessageRequest} body Message verification parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async verifyMessage(body: RequestsVerifyMessageRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesVerifyMessageResponse>> {
        return BitcoinApiFp(this.configuration).verifyMessage(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Verifies that a proof points to a transaction in a block
     * @summary Verify transaction output proof
     * @param {RequestsVerifyTxOutProofRequest} body Proof to verify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinApi
     */
    public async verifyTxOutProof(body: RequestsVerifyTxOutProofRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResponsesVerifyTxOutProofResponse>> {
        return BitcoinApiFp(this.configuration).verifyTxOutProof(body, options).then((request) => request(this.axios, this.basePath));
    }
}
